#pragma kernel CSUpdate
 
struct PosVelo
    {
        float3 position;
        float3 velocity;
    };
 
RWStructuredBuffer<PosVelo> oldPosVelo;
RWStructuredBuffer<PosVelo> newPosVelo;
 
float dt;
float damping;
uint numParticles;
uint dimx;
 
static float softeningSquared = 0.0012500000*0.0012500000;
static float fG = 6.67300e-11f * 10000.0f;
static float fParticleMass = fG*10000.0f * 10000.0f;
 
#define blockSize 128
groupshared float3 sharedPos[blockSize];
 
// Body to body interaction, acceleration of the particle at position bi is updated
void bodyBodyInteraction(inout float3 ai, float3 bj, float3 bi, float mass, int particles ) 
{
    float3 r = bj.xyz - bi.xyz;
 
    float distSqr = dot(r, r);
    distSqr += softeningSquared;
 
    float invDist = 1.0f / sqrt(distSqr);
    float invDistCube =  invDist * invDist * invDist;
 
    float s = mass * invDistCube * particles;
 
    ai += r * s;    
}
 
[numthreads(blockSize,1,1)]
void CSUpdate( uint3 Gid : SV_GroupID, uint3 DTid : SV_DispatchThreadID, uint3 GTid : SV_GroupThreadID, uint GI : SV_GroupIndex )
{
    // Each thread of the CS updates one of the particles
 
    float3 pos = oldPosVelo[DTid.x].position;
    float3 vel = oldPosVelo[DTid.x].velocity;
    float3 accel = 0;
    float mass = fParticleMass;
 
    // Update current particle using all other particles
    [loop]
    for (uint tile = 0; tile < dimx; tile++)
    {
        // Cache a tile of particles unto shared memory to increase IO efficiency
        sharedPos[GI] = oldPosVelo[tile * blockSize + GI].position;
 
        GroupMemoryBarrierWithGroupSync();        
 
        [unroll]
        for (uint counter = 0; counter < blockSize; counter+=8 ) 
        {
            bodyBodyInteraction(accel, sharedPos[counter], pos, mass, 1);
            bodyBodyInteraction(accel, sharedPos[counter+1], pos, mass, 1);
            bodyBodyInteraction(accel, sharedPos[counter+2], pos, mass, 1);
            bodyBodyInteraction(accel, sharedPos[counter+3], pos, mass, 1);
            bodyBodyInteraction(accel, sharedPos[counter+4], pos, mass, 1);
            bodyBodyInteraction(accel, sharedPos[counter+5], pos, mass, 1);
            bodyBodyInteraction(accel, sharedPos[counter+6], pos, mass, 1);
            bodyBodyInteraction(accel, sharedPos[counter+7], pos, mass, 1);
        }
 
        GroupMemoryBarrierWithGroupSync();
    }  
 
    // numParticles is the number of our particles, however this number might not be an exact multiple of the tile size.
    // In such cases, out of bound reads occur in the process above, which means there will be 
    // tooManyParticles "phantom" particles generating false gravity at position (0, 0, 0), so we have to substract them here.
    // NOTE, out of bound reads always return 0 in CS
    const uint tooManyParticles = dimx * blockSize - numParticles;
    bodyBodyInteraction(accel, float3(0, 0, 0), pos, mass, -tooManyParticles);
 
    // Update the velocity and position of current particle using the acceleration computed above
    vel.xyz += accel.xyz * dt;      //deltaTime;
    vel.xyz *= damping;             //damping;
    pos.xyz += vel.xyz * dt;        //deltaTime;    
 
    if ( DTid.x < numParticles )
    {
        newPosVelo[DTid.x].position = pos;
        newPosVelo[DTid.x].velocity = vel;
    }
}